{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> A tool for faster application development Plotly Dash \u26a1 </p>"},{"location":"#about","title":"About","text":"<p>DashExpress is a wrapper over the Plotly Dash web framework, which allows you to simplify and speed up the creation of multi-page analytical applications based on data from pd.DataFrame.</p> <p>The key features are:</p> <ul> <li>High Performance: Provided by built-in optimization methods of Dash callback functions.</li> <li>Fast to code: Using a pre-configured UI and automatically generated callback functions.</li> <li>Based on Pandas: A library familiar to all analysts.</li> <li>Used Mantine UI: Pretty UI by Mantine React Library</li> <li>Include Dark Theme: Use a dark theme for all components (including graphs and maps) without any additional actions.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.7+</p> <p>DashExpress stands on the shoulders of giants:</p> <ul> <li>Plotly Dash for the web parts.</li> <li>Pandas DataFrame for the data store &amp; compute measure.</li> <li>Dash Mantine Components for the create pretty UI</li> <li>Dash Leaflet for the create maps</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"authors/","title":"Authors","text":"<p>Hey! \ud83d\udc4b</p> <p>This is me: Stepanov Kirill</p> <p>I'm the creator of DashExpress. If you have any questions, contact me via telegram</p>"},{"location":"installation/","title":"Installation","text":"<p>In your terminal, install dash-express.</p> <pre><code>$ pip install dash-express\n\n---&gt; 100%\n</code></pre> <p>This also brings along the <code>Plotly Dash</code>, <code>Pandas</code>, <code>Dash Mantine Components</code> &amp; <code>Dash Leaflet</code> . This library is under active development, so install and upgrade frequently.</p> <p>We also recommend installing GeoPandas, which is required by Generated Geojson for leaflet maps and used in many of our examples.</p> Installation GeoPandas. <p>To install the released version, you can use pip:</p> <pre><code>pip install geopandas\n</code></pre> <p>or you can install the conda package from the conda-forge channel:</p> <pre><code>conda install -c conda-forge geopandas\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Dash Express takes care of improving performance instead of you, here are the ways built in by default:</p>"},{"location":"performance/#using-callbacks-on-the-client-side","title":"Using callbacks on the client side","text":"<p>Most of the callbacks are implemented on the client side, not on the server in Python.</p>"},{"location":"performance/#partial-property-updates","title":"Partial property updates","text":"<p>Graph creation functions are automatically converted to Patch objects, only updating the parts of a property that you want to change</p>"},{"location":"performance/#caching","title":"Caching","text":"<p>Dash Express uses the <code>Flash-Caching</code> library, which stores the results in a shared memory database such as Redis, or as a file in your file system.</p>"},{"location":"performance/#data-serialization-with-orjson","title":"Data Serialization with orjson","text":"<p>DashExpress uses <code>orjson</code> to speed up serialization to JSON and in turn improve your callback performance</p>"},{"location":"quickstart/","title":"Introduction to DashExpress","text":"<p>This quick tutorial introduces the key concepts and basic features of DashExpress to help you get started with your projects.</p>"},{"location":"quickstart/#concepts","title":"Concepts","text":"<p>Dash Express, as the name suggests, extends the popular web framework Plotly Dash, by adding responsive UI and generated automatic callback-functions. If you are not familiar with Dash, we recommend taking a quick look at its Getting started documentation before proceeding.</p> <p>The logic of creating a Dash Express application, like any dashboard, comes down to 4 stages:</p> <ol> <li>Data collection</li> <li>Creating a layout</li> <li>Filling layouts with visualizations</li> <li>Adding filtering</li> </ol> <p>Dash Express simplifies the second and fourth stages. The concept of Dash Express implies the rejection of the need to write callback functions. Despite the fact that writing such functions as a rule does not present any difficulty, it can be very tedious in the case of a large number of visualizations and (or) frequent changes in layout and content.</p>"},{"location":"quickstart/#basic-features","title":"Basic features","text":"<ol> <li>Pre-configured UI</li> <li>Automatic callback functions</li> <li>Autofilters</li> <li>An alternative implementation of multipage, with support for access depending on the user</li> </ol>"},{"location":"fundamentals/Add%20data/","title":"Add data","text":"<p>Data is the heart of any dashboard, so you need to pay maximum attention to getting a table. Optimized Data Frame will speed up calculations and reduce memory consumption.</p> <p>To optimize performance, you can use your own Pandas methods. Below are a few basic practices that will allow you to efficiently store and process large data sets.</p> Tip 1: Don't upload unnecessary data <p>Load only those columns that will be used for building visualizations and/or filtering</p> <pre><code>pd.read_csv('data.csv', usecols=['only', 'used', 'columns'])\n</code></pre> Tip 2: Use suitable data types <p>We can optimize the data types to reduce memory usage. By using the memory_usage() function, we can find the memory used by the data objects. It returns a series with an index of the original column names and values representing the amount of memory used by each column in bytes.</p> <p>The syntax of memory_usgae() as follows:</p> <pre><code>DataFrame.memory_usage(index=True, deep=False)\n</code></pre> <p>For numeric data, use the smallest possible data types In this code, columnsTMax of the int64 datatype is converted into the int32 datatype using the .astype() method. We can see the difference between the memory used by the TMax column. There is a decrease in memory usage.</p> <p><pre><code>data = pd.read_csv('https://raw.githubusercontent.com/toddwschneider/nyc-taxi-data/master/data/central_park_weather.csv')\nprint(\"Initially Memory usage:\")\nprint(data[['TMAX']].memory_usage(index=True, deep=False))\nprint()\ndata[['TMAX']]=data[['TMAX']].astype('int32')\nprint(\"Memory used after optimization:\")\nprint(data[['TMAX']].memory_usage(index=True, deep=False))\n</code></pre> <pre><code>Initially Memory usage:\nIndex      128\nTMAX     39432\nTMIN     39432\ndtype: int64\n\nMemory used after optimization:\nIndex     128\nTMAX     4929\nTMIN     4929\ndtype: int64\n</code></pre></p> <p>For non-numeric columns of Data Frame are assigned as object data types which can be changed to category data types. Usually, the non-numerical feature column has categorical variables which are mostly repeating. </p> <p><pre><code>import pandas as pd\ndata = pd.read_csv('https://raw.githubusercontent.com/toddwschneider/nyc-taxi-data/master/data/central_park_weather.csv')\n\nprint(\"Initially Memory usage:\")\nprint(data['NAME'].dtypes)\nprint(data['NAME'].memory_usage())\nprint()\ndata['NAME']=data['NAME'].astype('category')\nprint(\"Memory used after optimization:\")\nprint(data['NAME'].dtypes)\nprint(data['NAME'].memory_usage())\n</code></pre> <pre><code>Initially Memory usage:\nobject\n39560\n\nMemory used after optimization:\ncategory\n5173\n</code></pre></p> <p>The Page object must contain a data acquisition function, below is an example of obtaining data using optimization:</p> <pre><code>def get_df():\n    # We load only used columns\n    df =  pd.read_csv('titanic.csv', usecols=['survived', 'age', 'class', 'who', 'alone'])\n\n    # Convert to the optimal data format\n    df.age = df.age.fillna(0)\n    df = df.astype(\n        {\n            'survived': 'int8',\n            'age': 'int8',\n            'class': 'category',\n            'who': 'category',\n            'alone': 'bool'\n        }\n    )  \n    return df\n</code></pre> <p>The data collection function must be passed during initialization of the Page object</p> <pre><code>page = Page(\n    ...\n    getdf=get_df,               # \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f pd.DataFrame\n    ...\n    )\n</code></pre> <p>Note</p> <p>Note that Dash Express caches the Data Frame and does not request data for every filtering request.</p>"},{"location":"fundamentals/Create%20app/","title":"Minimal app","text":"<p>The first step is to import the necessary libraries</p> <pre><code>import pandas as pd\nimport plotly.express as px\nimport dash_mantine_components as dmc\n\nfrom dash_express import DashExpress, Page\n</code></pre> <p>Next, you need to initialize an instance of the Dash Express application. Note that Dash Express uses caching by default to improve performance.  If your application already has a flask_caching object.Cache you can pass it to Dash Express.</p> <pre><code>app = DashExpress(\n    logo='DashExpress',          # navbar logo, string or dict: {'dark':'path/to/darklogo.svg', 'light':...}\n    cache=True,                  # flask_caching.Cache instance, dict or True (default: True)\n    default_cache_timeout=3600,  # flask_caching.Cache timeout in seconds (default: 3600)\n    app_shell=...,               # Appshell class for customization UI your app (default: BaseAppShell())\n    # And standart Plotly Dash param\n )\n</code></pre> <p>The Dash Express object implements a Dash application with a pre-configured interface and automatic callback generation for quickly creating interactive multi-page web analytics applications.</p>"},{"location":"fundamentals/Create%20app/#page-definition","title":"Page definition","text":"<p>Each application page is a separate object, an instance of the <code>dash_express' class.Page</code>. The page contains the source data for analysis, graph creation functions and a list of filters.</p> <pre><code>page = Page(\n    app=app,                    # DashExpress app\n    url_path='/',               # page url\n    name='Owerview',            # page name in navigation buttons\n    get_df=get_df,              # function for getting pd.DataFrame\n    title='Owerview',           # page title\n    )\n</code></pre>"},{"location":"fundamentals/Create%20app/#getting-data","title":"Getting data","text":"<p>The 'get_df` function contains the logic of getting data: </p> <pre><code>get_df = lambda: pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv')\n</code></pre>"},{"location":"fundamentals/Create%20app/#dashboard-layout","title":"Dashboard layout","text":"<p>Next, you need to determine the layout of the dashboard. we recommend using dmc.Grid and dmc.SimpleGrid</p> <pre><code>page.layout = dmc.SimpleGrid(\n    page.add_graph(h='100%',render_func=bar_func)\n    )\n</code></pre> <p>The render_func parameter of the page.add_graph method is a graph generation function based on data from a DataFrame</p> <pre><code># The logic of drawing a graph\ndef bar_func(df):\n    pv = pd.pivot_table(df, index='continent', values='lifeExp').reset_index()\n    fig = go.Figure([go.Bar(x=pv['continent'], y=pv['lifeExp'])])\n    return fig\n</code></pre> <p>The last action is to add filters, which is done by simply calling the page.add_filter method and specifying the filtering column.</p> <pre><code>page.add_autofilter('continent', multi=True)\npage.add_autofilter('country', multi=True)\npage.add_autofilter('lifeExp', multi=True)\n</code></pre>"},{"location":"fundamentals/Create%20app/#app-run","title":"App run","text":"<p>These actions are enough to create a fully functional dashboard, so you can run the application.</p> <pre><code>app.run()\n</code></pre>"},{"location":"fundamentals/Create%20app/#full-code-of-the-minimal-application","title":"Full code of the minimal application","text":"<pre><code>import pandas as pd\nimport plotly.graph_objects as go\nimport dash_mantine_components as dmc\n\nfrom dash_express import DashExpress, Page\n\n\n# Incorporate data\nget_df = lambda: pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv')\n\n# Initialize the app\napp = DashExpress(logo='DashExpress')\n\n# Initialize the Page\npage = Page(\n    app=app,                    # DashExpress app\n    url_path='/',               # page url\n    name='Owerview',            # page name in navigation buttons\n    get_df=get_df,              # function for getting pd.DataFrame\n    title='Owerview',           # page title\n    )\n\n# The logic of drawing a graph\ndef bar_func(df):\n    pv = pd.pivot_table(df, index='continent', values='lifeExp').reset_index()\n    fig = go.Figure([go.Bar(x=pv['continent'], y=pv['lifeExp'])])\n    return fig\n\n# Dashboard layout\npage.layout = dmc.SimpleGrid(\n    page.add_graph(h='calc(100vh - 138px)',render_func=bar_func)\n    )\n\n# By which columns to filter\npage.add_autofilter('continent', multi=True)\npage.add_autofilter('country', multi=True)\npage.add_autofilter('lifeExp', multi=True)\n\napp.run(debug=True)\n</code></pre>"},{"location":"fundamentals/Create%20app/#requirements","title":"Requirements","text":"<p>Python 3.7+</p> <p>DashExpress stands on the shoulders of giants:</p> <ul> <li>Plotly Dash for the web parts.</li> <li>Pandas DataFrame for the data store &amp; compute measure.</li> <li>Dash Mantine Components for the create pretty UI</li> <li>Dash Leaflet for the create maps</li> </ul>"},{"location":"fundamentals/Create%20app/#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"fundamentals/Visualization/","title":"Visualization","text":""},{"location":"fundamentals/Visualization/#kpi-cards","title":"KPI cards","text":"<p>KPI cards are a basic part of monitoring business performance and tracking up-to-date information. Any card consists of a constant part (Container) and a variable part (KPI indicator)</p> <p>The KPI rendering system is based on the use of the KPI class, which contains a container representation and the logic for calculating the indicator. The simplest implementation of KPI, with automatic generation of the calculation function, is presented in the FastKPI class:</p> <p><pre><code>dmc.SimpleGrid(\n    [\n        app.add_kpi(FastKPI('survived', agg_func=func, h=150) for func in [np.mean, np.sum, np.max, np.min]\n    ],\n    cols=4\n    )\n</code></pre> FastKPI Initialization Parameters:</p> <pre><code>col = DataFrame Column\nagg_func = pivot func for calculate kpi\npretty_func = pretty func for result calculate, for example: lambda x: f'{x:.1%}'\ntitle = title of cards? default automatic generation\n</code></pre> <p>An advanced way to add KPI is to create your own card by inheriting from the base class of KPI:</p> <pre><code>from dash_express import KPI\n\nclass MyKPI(KPI):\n    def __init__(self, ...):\n        ...\n\n    def render_layout(self, id):\n'''Render Container'''\n        return dmc.Card(...)\n\n    def render_func(self,df):\n'''Compute &amp; Render value'''\n        return ...\n\napp.add_kpi(MyKPI())\n</code></pre>"},{"location":"fundamentals/Visualization/#plotly-figure","title":"Plotly Figure","text":"<p>The Plotly graphing library has more than 50 chart types to choose from. For Dash Express to work, you need to answer 2 questions:</p> <ol> <li>Where is the graph located</li> <li>How to build a graph</li> </ol> <p>The answer to the first question is laid when developing the layout, by calling the page.add_graph(...) method in the location of the graph, a simple example:</p> <pre><code>dmc.SimpleGrid(\n    [\n        page.add_graph(h='100%',render_func=bar_func),\n        page.add_graph(h='100%',render_func=line_func),\n    ],\n    cols=2\n    )\n</code></pre> <p>Through .add_graph is a function containing the logic of plotting to which the Dash Express application will pass the filtered DataFrame. <pre><code>def bar_func(df):\n    return px.bar(df, x=\"nation\", y=\"count\", color=\"medal\", title=\"Long-Form Input\")\n</code></pre></p> <p>Danger</p> <p>Render_func should return Plotly Figure, implementations from other libraries are not supported!</p>"},{"location":"fundamentals/Visualization/#leaflet-maps","title":"Leaflet maps","text":"<p>If you use GeoPandas, you can add maps to your dashboard, it's as simple as adding a graph.:</p> <pre><code>dmc.SimpleGrid(\n    [\n        page.add_map(geojson_func=None),\n    ],\n    cols=1\n    )\n</code></pre> <p>geojson_func - should return GeoDataFrame.get_interface, if you do not need any additional transformations, do not specify this parameter, DashExpress will do everything for you.</p> <pre><code>def geojson_func(gdf):\n    gdf = gdf[gdf.geometry.geom_type == 'Polygon']\n    return gdf.__geo_interface__\n</code></pre>"},{"location":"fundamentals/filters/","title":"Filtering","text":"<p>Adding filters is very easy if you use DashExpress. You only need to specify the column by which filtering will take place and say the type of filtering multi = True|False</p> <pre><code>page.add_autofilter('continent', multi=True)\n</code></pre> <p>You can also specify additional parameters of the Dash Mantine component.</p>"}]}